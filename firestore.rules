/**
 * @file firestore.rules
 * @description Firestore Security Rules for the application.
 *
 * ## Core Philosophy
 * This ruleset enforces a strict security model based on user ownership and clear segregation of public versus private data. The primary goal is to ensure that users can only access and manage their own information, while publicly accessible data (like products) is read-only for clients. All write operations are assumed to be performed by an administrative backend unless explicitly defined otherwise.
 *
 * ## Data Structure
 * The data is organized into three main top-level collections:
 * - `/products`: A public, read-only collection of all available products.
 * - `/featuredBanners`: A public, read-only collection of promotional banners.
 * - `/users`: A collection where each user's private data is stored under a document matching their UID (`/users/{userId}`).
 *   - `/users/{userId}/notifications`: A subcollection containing notifications private to that specific user.
 *
 * ## Key Security Decisions
 * - **Default Deny:** Access is denied by default. All rules explicitly grant permissions.
 * - **User Data Privacy:** A user's profile and notifications are strictly private. Access is granted only to the authenticated user whose UID matches the document path.
 * - **No User Enumeration:** Listing documents in the top-level `/users` collection is disallowed to prevent scraping user information.
 * - **Public Data is Read-Only:** Collections like `/products` and `/featuredBanners` are readable by anyone but cannot be modified by clients. This assumes such content is managed by a trusted server environment or the Firebase Console.
 * - **Path-Based Security:** User-specific data is secured using the `{userId}` wildcard in the path, which is the most performant and secure method for enforcing ownership.
 *
 * ## Denormalization for Authorization
 * The current data model is simple and does not require complex authorization checks that would necessitate denormalization. For example, a user's notifications are located directly under their user path (`/users/{userId}/notifications`), so ownership can be determined from the path alone without needing `get()` calls to other documents.
 *
 * ## Structural Segregation
 * The ruleset leverages structural segregation effectively. Public, read-only data (`products`, `featuredBanners`) is kept in separate top-level collections from private, user-owned data (`users/{userId}` and its subcollections). This separation simplifies rules and makes queries more secure and efficient.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document exists AND the user is the owner.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Manages product listings, which are public and read-only.
     * @path /products/{productId}
     * @allow (get, list) An anonymous or authenticated user can read product data.
     * @deny (create, update, delete) Any client attempt to modify product data is blocked.
     * @principle Public data should be read-only for clients to prevent unauthorized modification. Content is managed by a trusted admin backend.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages featured banners, which are public and read-only.
     * @path /featuredBanners/{bannerId}
     * @allow (get, list) An anonymous or authenticated user can view banner data.
     * @deny (create, update, delete) Any client attempt to modify banner data is blocked.
     * @principle Public data should be read-only for clients to prevent unauthorized modification. Content is managed by a trusted admin backend.
     */
    match /featuredBanners/{bannerId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) A new user can create their own profile document. `auth.uid` must match `{userId}`.
     * @allow (get, update, delete) An authenticated user can read, update, or delete their own profile.
     * @deny (list) No one can list all users to prevent user enumeration.
     * @deny (get, update, delete) A user cannot access another user's profile.
     * @principle Restricts access to a user's own data tree and prevents enumeration of user data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages user-specific notifications.
       * @path /users/{userId}/notifications/{notificationId}
       * @allow (get, list) A user can read their own notifications.
       * @allow (create, update, delete) A user can create, update (e.g., mark as read), and delete their own notifications.
       * @deny (any) A user cannot access notifications belonging to another user.
       * @principle Enforces document ownership for all operations within a user-specific subcollection.
       */
      match /notifications/{notificationId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}