/**
 * @file firestore.rules
 * @description Firestore Security Rules for the application.
 *
 * ## Core Philosophy
 * This ruleset enforces a strict security model based on user ownership and clear segregation of public versus private data. The primary goal is to ensure that users can only access and manage their own information, while publicly accessible data (like products) is read-only for clients unless the user is an admin.
 *
 * ## Data Structure
 * - `/products`: A public collection of all available products. Read-only for normal users, writable for admins.
 * - `/featuredBanners`: A public collection of promotional banners. Read-only for normal users, writable for admins.
 * - `/users`: A collection where each user's private data is stored under a document matching their UID (`/users/{userId}`).
 *   - `/users/{userId}/notifications`: A subcollection containing notifications private to that specific user.
 *   - `/users/{userId}/orders`: A subcollection containing order history private to that specific user.
 * - `/admins`: A collection storing the UIDs of admin users. This is used for role-based access control.
 *
 * ## Key Security Decisions
 * - **Default Deny:** Access is denied by default. All rules explicitly grant permissions.
 * - **User Data Privacy:** A user's profile, notifications, and orders are strictly private. Access is granted only to the authenticated user whose UID matches the document path.
 * - **Admin-Managed Public Data:** Collections like `/products` and `/featuredBanners` are readable by anyone but can only be modified by users designated as admins.
 * - **Admin User Management:** Admins can list all users and update their balances. Regular users cannot list other users.
 * - **Path-Based Security:** User-specific data is secured using the `{userId}` wildcard in the path.
 * - **Role-Based Security:** Admin privileges are determined by checking for the user's UID in the `/admins` collection.
 *
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document exists AND the user is the owner.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    
    /**
     * Returns true if the incoming data for a user document is valid on creation.
     * - Balance must be 0.
     */
    function isValidUserCreate() {
      return request.resource.data.balance == 0;
    }
    
    /**
     * Returns true if a user's update to their own document is valid.
     * - They cannot change their own balance.
     */
    function isValidUserUpdate() {
      // Regular users cannot change their own balance.
      return request.resource.data.balance == resource.data.balance;
    }

    /**
     * Returns true if the requesting user is an admin.
     * Checks for the user's UID in the /admins collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }


    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------
    
    /**
     * @description Manages admin user records. Publicly readable, admin-only writable.
     * @path /admins/{userId}
     * @allow (get, list) Anyone can check if a UID is in the admin list. This is safe because UIDs are not sensitive.
     * @allow (write) Only existing admins can manage the list of other admins.
     * @deny (any) Non-admins cannot modify this collection.
     */
    match /admins/{userId} {
      allow get, list: if true;
      allow write: if isAdmin();
    }

    /**
     * @description Manages product listings. Publicly readable, but only admins can modify.
     * @path /products/{productId}
     * @allow (get, list) An anonymous or authenticated user can read product data.
     * @allow (write) Only admins can modify product data.
     * @principle Segregates public read access from privileged write access.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow write: if isAdmin();
    }

    /**
     * @description Manages featured banners. Publicly readable, but only admins can modify.
     * @path /featuredBanners/{bannerId}
     * @allow (get, list) An anonymous or authenticated user can view banner data.
     * @allow (create, update, delete) Only admins can modify banner data.
     * @principle Segregates public read access from privileged write access.
     */
    match /featuredBanners/{bannerId} {
      allow get: if true;
      allow list: if true;
      allow write: if isAdmin();
    }
    
    /**
     * @description Collection group query rule for 'orders'.
     * @path /{path=**}/orders/{orderId}
     * @allow (list) Admins can list all pending orders across all users for management.
     */
    match /{path=**}/orders/{orderId} {
      allow list: if isAdmin() && request.query.where.status == 'Pending';
    }

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (get) Owner can read their own profile. Admins can read any profile.
     * @allow (list) Admins can list all users. Users can query for username existence.
     * @allow (create) A new user can create their own profile.
     * @allow (update) Owner can update their profile (but not balance). Admins can update any user's profile.
     * @allow (delete) Owner can delete their own profile.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin() || (isSignedIn() && request.query.keys().hasOnly(['username']));
      allow create: if isOwner(userId) && request.resource.data.id == userId && isValidUserCreate();
      allow update: if (isOwner(userId) && isValidUserUpdate()) || isAdmin();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages user-specific notifications.
       * @path /users/{userId}/notifications/{notificationId}
       * @allow (get, list) A user can read their own notifications.
       * @allow (create, update, delete) A user can create, update (e.g., mark as read), and delete their own notifications.
       * @deny (any) A user cannot access notifications belonging to another user.
       * @principle Enforces document ownership for all operations within a user-specific subcollection.
       */
      match /notifications/{notificationId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
      
      /**
       * @description Manages user-specific order history.
       * @path /users/{userId}/orders/{orderId}
       * @allow (get, list) A user can read their own orders. Admins can also get individual orders.
       * @allow (create) A user can create their own orders.
       * @allow (update) A user can update their own orders. Admins can also update orders (e.g. status).
       * @deny (any) A user cannot access orders belonging to another user.
       * @principle Enforces document ownership for all operations within a user-specific subcollection.
       */
      match /orders/{orderId} {
        allow get: if isOwner(userId) || isAdmin();
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) || isAdmin();
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}
