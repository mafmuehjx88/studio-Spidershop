/**
 * @file firestore.rules
 * @description Firestore Security Rules for the application.
 *
 * ## Core Philosophy
 * This ruleset enforces a strict security model based on user ownership and clear segregation of public versus private data. The primary goal is to ensure that users can only access and manage their own information, while publicly accessible data (like products) is read-only for clients unless the user is an admin.
 *
 * ## Data Structure
 * - `/products`: A public collection of all available products. Read-only for normal users, writable for admins.
 * - `/featuredBanners`: A public collection of promotional banners. Read-only for normal users, writable for admins.
 * - `/users`: A collection where each user's private data is stored under a document matching their UID (`/users/{userId}`).
 *   - `/users/{userId}/notifications`: A subcollection containing notifications private to that specific user.
 *   - `/users/{userId}/orders`: A subcollection containing order history private to that specific user.
 * - `/admins`: A collection storing the UIDs of admin users. This is used for role-based access control.
 *
 * ## Key Security Decisions
 * - **Default Deny:** Access is denied by default. All rules explicitly grant permissions.
 * - **User Data Privacy:** A user's profile, notifications, and orders are strictly private. Access is granted only to the authenticated user whose UID matches the document path.
 * - **No User Enumeration:** Listing documents in the top-level `/users` collection is disallowed to prevent scraping user information.
 * - **Admin-Managed Public Data:** Collections like `/products` and `/featuredBanners` are readable by anyone but can only be modified by users designated as admins.
 * - **Path-Based Security:** User-specific data is secured using the `{userId}` wildcard in the path.
 * - **Role-Based Security:** Admin privileges are determined by checking for the user's UID in the `/admins` collection.
 *
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document exists AND the user is the owner.
     * Used for safe update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    
    /**
     * Returns true if the incoming data for a user document is valid.
     * - Balance can only be set to 0 on creation.
     * - Balance cannot be updated directly by the client.
     */
    function isValidUserCreate() {
      return request.resource.data.balance == 0;
    }
    
    function isValidUserUpdate() {
      return request.resource.data.balance == resource.data.balance;
    }

    /**
     * Returns true if the requesting user is an admin.
     * Checks for the user's UID in the /admins collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/admins/$(request.auth.uid));
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------
    
    /**
     * @description Manages admin user records. Only admins can read or write to this list.
     * @path /admins/{userId}
     * @allow (any) Admins can manage the list of other admins.
     * @deny (any) Non-admins cannot read or modify this collection.
     */
    match /admins/{userId} {
      allow read, write: if isAdmin();
    }

    /**
     * @description Manages product listings. Publicly readable, but only admins can modify.
     * @path /products/{productId}
     * @allow (get, list) An anonymous or authenticated user can read product data.
     * @allow (create, update, delete) Only admins can modify product data.
     * @principle Segregates public read access from privileged write access.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow write: if isAdmin();
    }

    /**
     * @description Manages featured banners. Publicly readable, but only admins can modify.
     * @path /featuredBanners/{bannerId}
     * @allow (get, list) An anonymous or authenticated user can view banner data.
     * @allow (create, update, delete) Only admins can modify banner data.
     * @principle Segregates public read access from privileged write access.
     */
    match /featuredBanners/{bannerId} {
      allow get: if true;
      allow list: if true;
      allow write: if isAdmin();
    }

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) A new user can create their own profile document. `auth.uid` must match `{userId}`.
     * @allow (get, update, delete) An authenticated user can read, update, or delete their own profile.
     * @deny (list) No one can list all users to prevent user enumeration.
     * @deny (get, update, delete) A user cannot access another user's profile.
     * @principle Restricts access to a user's own data tree and prevents enumeration of user data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId && isValidUserCreate();
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages user-specific notifications.
       * @path /users/{userId}/notifications/{notificationId}
       * @allow (get, list) A user can read their own notifications.
       * @allow (create, update, delete) A user can create, update (e.g., mark as read), and delete their own notifications.
       * @deny (any) A user cannot access notifications belonging to another user.
       * @principle Enforces document ownership for all operations within a user-specific subcollection.
       */
      match /notifications/{notificationId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
      
      /**
       * @description Manages user-specific order history.
       * @path /users/{userId}/orders/{orderId}
       * @allow (get, list) A user can read their own orders.
       * @allow (create) A user can create their own orders.
       * @allow (update, delete) A user can update or delete their own orders (e.g. cancel).
       * @deny (any) A user cannot access orders belonging to another user.
       * @principle Enforces document ownership for all operations within a user-specific subcollection.
       */
      match /orders/{orderId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}

    